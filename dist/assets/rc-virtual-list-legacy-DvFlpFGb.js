System.register(["./@babel-legacy-Hf2i0Sc8.js","./classnames-legacy-DmWFIwmD.js","./rc-resize-observer-legacy-DC8CZSyw.js","./rc-util-legacy-BQceI0rf.js","./react-legacy-tsTD2afp.js","./react-dom-legacy-oo3lAXd2.js"],(function(e,t){"use strict";var n,r,o,i,u,c,a,l,s,f,v,d,h,g,m,p;return{setters:[function(e){n=e.e,r=e.b,o=e.g,i=e.c,u=e.d,c=e._,a=e.a,l=e.h},function(e){s=e.c},function(e){f=e.R},function(e){v=e.q,d=e.G,h=e.u,g=e.i},function(e){m=e.r},function(e){p=e.r}],execute:function(){
/**
       * Fill component to provided the scroll content real height.
       */
var t=m.forwardRef((function(e,t){var i=e.height,u=e.offsetY,c=e.offsetX,a=e.children,l=e.prefixCls,v=e.onInnerResize,d=e.innerProps,h=e.rtl,g=e.extra,p={},y={display:"flex",flexDirection:"column"};return void 0!==u&&(// Not set `width` since this will break `sticky: right`
p={height:i,position:"relative",overflow:"hidden"},y=n(n({},y),{},r(r(r(r(r({transform:"translateY(".concat(u,"px)")},h?"marginRight":"marginLeft",-c),"position","absolute"),"left",0),"right",0),"top",0))),m.createElement("div",{style:p},m.createElement(f,{onResize:function(e){e.offsetHeight&&v&&v()}},m.createElement("div",o({style:y,className:s(r({},"".concat(l,"-holder-inner"),l)),ref:t},d),a,g)))}));function y(e){var t=e.children,n=e.setRef,r=m.useCallback((function(e){n(e)}),[]);return m.cloneElement(t,{ref:r})}function b(e,t,n){var r=m.useState(e),o=i(r,2),u=o[0],c=o[1],a=m.useState(null),l=i(a,2),s=l[0],f=l[1];return m.useEffect((function(){var n=
/**
       * Get index with specific start index one by one. e.g.
       * min: 3, max: 9, start: 6
       *
       * Return index is:
       * [0]: 6
       * [1]: 7
       * [2]: 5
       * [3]: 8
       * [4]: 4
       * [5]: 9
       * [6]: 3
       */
/**
       * We assume that 2 list has only 1 item diff and others keeping the order.
       * So we can use dichotomy algorithm to find changed one.
       */
function(e,t,n){var r,o,i=e.length,u=t.length;if(0===i&&0===u)return null;i<u?(r=e,o=t):(r=t,o=e);var c={__EMPTY_ITEM__:!0};function a(e){return void 0!==e?n(e):c}// Loop to find diff one
for(var l=null,s=1!==Math.abs(i-u),f=0;f<o.length;f+=1){var v=a(r[f]);if(v!==a(o[f])){l=f,s=s||v!==a(o[f+1]);break}}return null===l?null:{index:l,multiple:s}}(u||[],e||[],t);void 0!==(null==n?void 0:n.index)&&f(e[n.index]),c(e)}),[e]),[s]}t.displayName="Filler";var S="object"===("undefined"==typeof navigator?"undefined":u(navigator))&&/Firefox/i.test(navigator.userAgent),M=function(e,t){// Do lock for a wheel when scrolling
var n=m.useRef(!1),r=m.useRef(null),o=m.useRef({top:e,bottom:t});return o.current.top=e,o.current.bottom=t,function(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=// Pass origin wheel when on the top
e<0&&o.current.top||// Pass origin wheel when on the bottom
e>0&&o.current.bottom;return t&&i?(// No need lock anymore when it's smooth offset from touchMove interval
clearTimeout(r.current),n.current=!1):i&&!n.current||(clearTimeout(r.current),n.current=!0,r.current=setTimeout((function(){n.current=!1}),50)),!n.current&&i}};function R(e,t,n,r,
/***
       * Return `true` when you need to prevent default event
       */
o){var i=m.useRef(0),u=m.useRef(null),c=m.useRef(null),a=m.useRef(!1),l=M(t,n),s=m.useRef(null),f=m.useRef(null);return[function(t){if(e){// Wait for 2 frame to clean direction
v.cancel(f.current),f.current=v((function(){s.current=null}),2);var n=t.deltaX,d=t.deltaY,h=t.shiftKey,g=n,m=d;("sx"===s.current||!s.current&&h&&d&&!n)&&(g=d,m=0,s.current="sx");var p=Math.abs(g),y=Math.abs(m);null===s.current&&(s.current=r&&p>y?"x":"y"),"y"===s.current?function(e,t){v.cancel(u.current),i.current+=t,c.current=t,// Do nothing when scroll at the edge, Skip check when is in scroll
l(t)||(// Proxy of scroll events
S||e.preventDefault(),u.current=v((function(){// Patch a multiple for Firefox to fix wheel number too small
// ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
var e=a.current?10:1;o(i.current*e),i.current=0})))}(t,m):function(e,t){o(t,!0),S||e.preventDefault()}// Check for which direction does wheel do. `sx` means `shift + wheel`
(t,g)}}// A patch for firefox
,function(t){e&&(a.current=t.detail===c.current)}]}
/**
       * Size info need loop query for the `heights` which will has the perf issue.
       * Let cache result for each render phase.
       */ // Firefox has low performance of map.
var E=function(){function e(){a(this,e),r(this,"maps",void 0),// Used for cache key
// `useMemo` no need to update if `id` not change
r(this,"id",0),this.maps=Object.create(null)}return c(e,[{key:"set",value:function(e,t){this.maps[e]=t,this.id+=1}},{key:"get",value:function(e){return this.maps[e]}}]),e}(),w=14/15,x=10;function L(e,t){return("touches"in e?e.touches[0]:e)[t?"pageX":"pageY"]}var H=m.forwardRef((function(e,t){var o=e.prefixCls,u=e.rtl,c=e.scrollOffset,a=e.scrollRange,l=e.onStartMove,f=e.onStopMove,d=e.onScroll,h=e.horizontal,g=e.spinSize,p=e.containerSize,y=e.style,b=e.thumbStyle,S=m.useState(!1),M=i(S,2),R=M[0],E=M[1],w=m.useState(null),x=i(w,2),H=x[0],z=x[1],T=m.useState(null),Y=i(T,2),N=Y[0],k=Y[1],D=!u,j=m.useRef(),C=m.useRef(),I=m.useState(!1),P=i(I,2),O=P[0],A=P[1],X=m.useRef(),_=function(){clearTimeout(X.current),A(!0),X.current=setTimeout((function(){A(!1)}),3e3)},K=a-p||0,B=p-g||0,V=m.useMemo((function(){return 0===c||0===K?0:c/K*B}),[c,K,B]),W=m.useRef({top:V,dragging:R,pageY:H,startTop:N});W.current={top:V,dragging:R,pageY:H,startTop:N};var F=function(e){E(!0),z(L(e,h)),k(W.current.top),l(),e.stopPropagation(),e.preventDefault()};m.useEffect((function(){var e=function(e){e.preventDefault()},t=j.current,n=C.current;return t.addEventListener("touchstart",e),n.addEventListener("touchstart",F),function(){t.removeEventListener("touchstart",e),n.removeEventListener("touchstart",F)}}),[]);var q=m.useRef();q.current=K;var G=m.useRef();G.current=B,m.useEffect((function(){if(R){var e,t=function(t){var n=W.current,r=n.dragging,o=n.pageY,i=n.startTop;if(v.cancel(e),r){var u=L(t,h)-o,c=i;!D&&h?c-=u:c+=u;var a=q.current,l=G.current,s=l?c/l:0,f=Math.ceil(s*a);f=Math.max(f,0),f=Math.min(f,a),e=v((function(){d(f,h)}))}},n=function(){E(!1),f()};return window.addEventListener("mousemove",t),window.addEventListener("touchmove",t),window.addEventListener("mouseup",n),window.addEventListener("touchend",n),function(){window.removeEventListener("mousemove",t),window.removeEventListener("touchmove",t),window.removeEventListener("mouseup",n),window.removeEventListener("touchend",n),v.cancel(e)}}}),[R]),m.useEffect((function(){_()}),[c]),m.useImperativeHandle(t,(function(){return{delayHidden:_}}));var J="".concat(o,"-scrollbar"),Q={position:"absolute",visibility:O?null:"hidden"},U={position:"absolute",background:"rgba(0, 0, 0, 0.5)",borderRadius:99,cursor:"pointer",userSelect:"none"};return h?(Q.height=8,Q.left=0,Q.right=0,Q.bottom=0,U.height="100%",U.width=g,D?U.left=V:U.right=V):(Q.width=8,Q.top=0,Q.bottom=0,D?Q.right=0:Q.left=0,U.width="100%",U.height=g,U.top=V),m.createElement("div",{ref:j,className:s(J,r(r(r({},"".concat(J,"-horizontal"),h),"".concat(J,"-vertical"),!h),"".concat(J,"-visible"),O)),style:n(n({},Q),y),onMouseDown:function(e){e.stopPropagation(),e.preventDefault()},onMouseMove:_},m.createElement("div",{ref:C,className:s("".concat(J,"-thumb"),r({},"".concat(J,"-thumb-moving"),R)),style:n(n({},U),b),onMouseDown:F}))})),z=20;function T(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=e/(arguments.length>1&&void 0!==arguments[1]?arguments[1]:0)*e;return isNaN(t)&&(t=0),t=Math.max(t,z),Math.floor(t)}var Y=["prefixCls","className","height","itemHeight","fullHeight","style","data","children","itemKey","virtual","direction","scrollWidth","component","onScroll","onVirtualScroll","onVisibleChange","innerProps","extraRender","styles"],N=[],k={overflowY:"auto",overflowAnchor:"none"};function D(e,c){var a=e.prefixCls,S=void 0===a?"rc-virtual-list":a,L=e.className,z=e.height,D=e.itemHeight,j=e.fullHeight,C=void 0===j||j,I=e.style,P=e.data,O=e.children,A=e.itemKey,X=e.virtual,_=e.direction,K=e.scrollWidth,B=e.component,V=void 0===B?"div":B,W=e.onScroll,F=e.onVirtualScroll,q=e.onVisibleChange,G=e.innerProps,J=e.extraRender,Q=e.styles,U=l(e,Y),Z=m.useCallback((function(e){return"function"==typeof A?A(e):null==e?void 0:e[A]}),[A]),$=function(e,t,n){var r=m.useState(0),o=i(r,2),u=o[0],c=o[1],a=m.useRef(new Map),l=m.useRef(new E),s=m.useRef();function f(){v.cancel(s.current)}function h(){var e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];f();var t=function(){a.current.forEach((function(e,t){if(e&&e.offsetParent){var n=d(e),r=n.offsetHeight;l.current.get(t)!==r&&l.current.set(t,n.offsetHeight)}})),// Always trigger update mark to tell parent that should re-calculate heights when resized
c((function(e){return e+1}))};e?t():s.current=v(t)}return m.useEffect((function(){return f}),[]),[function(t,n){var r=e(t);a.current.get(r),n?(a.current.set(r,n),h()):a.current.delete(r)},h,l.current,u]}(Z),ee=i($,4),te=ee[0],ne=ee[1],re=ee[2],oe=ee[3],ie=!(!1===X||!z||!D),ue=m.useMemo((function(){return Object.values(re.maps).reduce((function(e,t){return e+t}),0)}),[re.id,re.maps]),ce=ie&&P&&(Math.max(D*P.length,ue)>z||!!K),ae="rtl"===_,le=s(S,r({},"".concat(S,"-rtl"),ae),L),se=P||N,fe=m.useRef(),ve=m.useRef(),de=m.useState(0),he=i(de,2),ge=he[0],me=he[1],pe=m.useState(0),ye=i(pe,2),be=ye[0],Se=ye[1],Me=m.useState(!1),Re=i(Me,2),Ee=Re[0],we=Re[1],xe=function(){we(!0)},Le=function(){we(!1)},He={getKey:Z};// =============================== Item Key ===============================
// ================================ Scroll ================================
function ze(e){me((function(t){var n=function(e){var t=e;return Number.isNaN(qe.current)||(t=Math.min(t,qe.current)),t=Math.max(t,0)}("function"==typeof e?e(t):e);return fe.current.scrollTop=n,n}))}// ================================ Legacy ================================
// Put ref here since the range is generate by follow
var Te=m.useRef({start:0,end:se.length}),Ye=m.useRef(),Ne=b(se,Z),ke=i(Ne,1)[0];Ye.current=ke;// ========================== Visible Calculation =========================
var De=m.useMemo((function(){if(!ie)return{scrollHeight:void 0,start:0,end:se.length-1,offset:void 0};// Always use virtual scroll bar in avoid shaking
var e;if(!ce)return{scrollHeight:(null===(e=ve.current)||void 0===e?void 0:e.offsetHeight)||0,start:0,end:se.length-1,offset:void 0};for(var t,n,r,o=0,i=se.length,u=0;u<i;u+=1){var c=se[u],a=Z(c),l=re.get(a),s=o+(void 0===l?D:l);// Check item top in the range
s>=ge&&void 0===t&&(t=u,n=o),// Check item bottom in the range. We will render additional one item for motion usage
s>ge+z&&void 0===r&&(r=u),o=s}// When scrollTop at the end but data cut to small count will reach this
return void 0===t&&(t=0,n=0,r=Math.ceil(z/D)),void 0===r&&(r=se.length-1),{scrollHeight:o,start:t,end:// Give cache to improve scroll experience
r=Math.min(r+1,se.length-1),offset:n}}),[ce,ie,ge,se,oe,z]),je=De.scrollHeight,Ce=De.start,Ie=De.end,Pe=De.offset;Te.current.start=Ce,Te.current.end=Ie;// ================================= Size =================================
var Oe=m.useState({width:0,height:z}),Ae=i(Oe,2),Xe=Ae[0],_e=Ae[1],Ke=m.useRef(),Be=m.useRef(),Ve=m.useMemo((function(){return T(Xe.width,K)}),[Xe.width,K]),We=m.useMemo((function(){return T(Xe.height,je)}),[Xe.height,je]),Fe=je-z,qe=m.useRef(Fe);qe.current=Fe;var Ge=ge<=0,Je=ge>=Fe,Qe=M(Ge,Je),Ue=function(){return{x:ae?-be:be,y:ge}},Ze=m.useRef(Ue()),$e=g((function(e){if(F){var t=n(n({},Ue()),e);// Trigger when offset changed
Ze.current.x===t.x&&Ze.current.y===t.y||(F(t),Ze.current=t)}}));function et(e,t){var n=e;t?(p.flushSync((function(){Se(n)})),$e()):ze(n)}// When data size reduce. It may trigger native scroll event back to fit scroll position
var tt=function(e){var t=e,n=K?K-Xe.width:0;return t=Math.max(t,0),t=Math.min(t,n)},nt=g((function(e,t){t?(// Horizontal scroll no need sync virtual position
p.flushSync((function(){Se((function(t){return tt(t+(ae?-e:e))}))})),$e()):ze((function(t){return t+e}))})),rt=R(ie,Ge,Je,!!K,nt),ot=i(rt,2),it=ot[0],ut=ot[1];// Mobile touch move
!function(e,t,n){var r,o=m.useRef(!1),i=m.useRef(0),u=m.useRef(null),c=m.useRef(null),a=function(e){if(o.current){var t=Math.ceil(e.touches[0].pageY),r=i.current-t;i.current=t,n(r)&&e.preventDefault(),// Smooth interval
clearInterval(c.current),c.current=setInterval((function(){(!n(r*=w,!0)||Math.abs(r)<=.1)&&clearInterval(c.current)}),16)}},l=function(){o.current=!1,r()},s=function(e){r(),1!==e.touches.length||o.current||(o.current=!0,i.current=Math.ceil(e.touches[0].pageY),u.current=e.target,u.current.addEventListener("touchmove",a),u.current.addEventListener("touchend",l))};r=function(){u.current&&(u.current.removeEventListener("touchmove",a),u.current.removeEventListener("touchend",l))},h((function(){return e&&t.current.addEventListener("touchstart",s),function(){var e;null===(e=t.current)||void 0===e||e.removeEventListener("touchstart",s),r(),clearInterval(c.current)}}),[e])}(ie,fe,(function(e,t){return!Qe(e,t)&&(it({preventDefault:function(){},deltaY:e}),!0)})),h((function(){// Firefox only
function e(e){ie&&e.preventDefault()}var t=fe.current;return t.addEventListener("wheel",it),t.addEventListener("DOMMouseScroll",ut),t.addEventListener("MozMousePixelScroll",e),function(){t.removeEventListener("wheel",it),t.removeEventListener("DOMMouseScroll",ut),t.removeEventListener("MozMousePixelScroll",e)}}),[ie]),// Sync scroll left
h((function(){if(K){var e=tt(be);Se(e),$e({x:e})}}),[Xe.width,K]);// ================================= Ref ==================================
var ct=function(){var e,t;null===(e=Ke.current)||void 0===e||e.delayHidden(),null===(t=Be.current)||void 0===t||t.delayHidden()},at=function(e,t,r,o,c,a,l,s){var f=m.useRef(),d=m.useState(null),g=i(d,2),p=g[0],y=g[1];return h((function(){if(p&&p.times<x){if(!e.current)return void y((function(e){return n({},e)}));a();var i=p.targetAlign,u=p.originAlign,s=p.index,f=p.offset,v=e.current.clientHeight,d=!1,h=i,g=null;if(v){for(var m=i||u,b=0,S=0,M=0,R=Math.min(t.length-1,s),E=0;E<=R;E+=1){var w=c(t[E]);S=b;var L=r.get(w);b=M=S+(void 0===L?o:L)}for(var H="top"===m?f:v-f,z=R;z>=0;z-=1){var T=c(t[z]),Y=r.get(T);if(void 0===Y){d=!0;break}if((H-=Y)<=0)break}switch(m){case"top":g=S-f;break;case"bottom":g=M-v+f;break;default:var N=e.current.scrollTop;S<N?h="top":M>N+v&&(h="bottom")}null!==g&&l(g),g!==p.lastTop&&(d=!0)}d&&y(n(n({},p),{},{times:p.times+1,targetAlign:h,lastTop:g}))}}),[p,e.current]),function(e){if(null!=e){if(v.cancel(f.current),"number"==typeof e)l(e);else if(e&&"object"===u(e)){var n,r=e.align;n="index"in e?e.index:t.findIndex((function(t){return c(t)===e.key}));var o=e.offset;y({times:0,index:n,offset:void 0===o?0:o,originAlign:r})}}else s()}}(fe,se,re,D,Z,(function(){return ne(!0)}),ze,ct);m.useImperativeHandle(c,(function(){return{getScrollInfo:Ue,scrollTo:function(e){var t;(t=e)&&"object"===u(t)&&("left"in t||"top"in t)?(// Scroll X
void 0!==e.left&&Se(tt(e.left)),// Scroll Y
at(e.top)):at(e)}}})),// ================================ Effect ================================
/** We need told outside that some list not rendered */h((function(){if(q){var e=se.slice(Ce,Ie+1);q(e,se)}}),[Ce,Ie,se]);// ================================ Extra =================================
var lt=function(e,t,n,r){var o=m.useMemo((function(){return[new Map,[]]}),[e,n.id,r]),u=i(o,2),c=u[0],a=u[1];return function(o){var i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o,u=c.get(o),l=c.get(i);// Get from cache first
// Loop to fill the cache
if(void 0===u||void 0===l)for(var s=e.length,f=a.length;f<s;f+=1){var v,d=e[f],h=t(d);c.set(h,f);var g=null!==(v=n.get(h))&&void 0!==v?v:r;if(a[f]=(a[f-1]||0)+g,h===o&&(u=f),h===i&&(l=f),void 0!==u&&void 0!==l)break}return{top:a[u-1]||0,bottom:a[l]}}}(se,Z,re,D),st=null==J?void 0:J({start:Ce,end:Ie,virtual:ce,offsetX:be,offsetY:Pe,rtl:ae,getSize:lt}),ft=function(e,t,n,r,o,i,u){var c=u.getKey;return e.slice(t,n+1).map((function(e,n){var u=i(e,t+n,{style:{width:r}}),a=c(e);return m.createElement(y,{key:a,setRef:function(t){return o(e,t)}},u)}))}(se,Ce,Ie,K,te,O,He),vt=null;z&&(vt=n(r({},C?"height":"maxHeight",z),k),ie&&(vt.overflowY="hidden",K&&(vt.overflowX="hidden"),Ee&&(vt.pointerEvents="none")));var dt={};return ae&&(dt.dir="rtl"),m.createElement("div",o({style:n(n({},I),{},{position:"relative"}),className:le},dt,U),m.createElement(f,{onResize:function(e){_e({width:e.width||e.offsetWidth,height:e.height||e.offsetHeight})}},m.createElement(V,{className:"".concat(S,"-holder"),style:vt,ref:fe,onScroll:function(e){var t=e.currentTarget.scrollTop;t!==ge&&ze(t),// Trigger origin onScroll
null==W||W(e),$e()},onMouseEnter:ct},m.createElement(t,{prefixCls:S,height:je,offsetX:be,offsetY:Pe,scrollWidth:K,onInnerResize:ne,ref:ve,innerProps:G,rtl:ae,extra:st},ft))),ce&&je>z&&m.createElement(H,{ref:Ke,prefixCls:S,scrollOffset:ge,scrollRange:je,rtl:ae,onScroll:et,onStartMove:xe,onStopMove:Le,spinSize:We,containerSize:Xe.height,style:null==Q?void 0:Q.verticalScrollBar,thumbStyle:null==Q?void 0:Q.verticalScrollBarThumb}),ce&&K>Xe.width&&m.createElement(H,{ref:Be,prefixCls:S,scrollOffset:be,scrollRange:K,rtl:ae,onScroll:et,onStartMove:xe,onStopMove:Le,spinSize:Ve,containerSize:Xe.width,horizontal:!0,style:null==Q?void 0:Q.horizontalScrollBar,thumbStyle:null==Q?void 0:Q.horizontalScrollBarThumb}))}e("L",m.forwardRef(D)).displayName="List"}}}));
