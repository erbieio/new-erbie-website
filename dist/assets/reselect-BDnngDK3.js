function T(e,n="expected a function, instead received ".concat(typeof e)){if(typeof e!="function")throw new TypeError(n)}function z(e,n="expected an object, instead received ".concat(typeof e)){if(typeof e!="object")throw new TypeError(n)}function N(e,n="expected all items to be functions, instead received the following types: "){if(!e.every(r=>typeof r=="function")){const r=e.map(s=>typeof s=="function"?"function ".concat(s.name||"unnamed","()"):typeof s).join(", ");throw new TypeError("".concat(n,"[").concat(r,"]"))}}var b=e=>Array.isArray(e)?e:[e];function E(e){const n=Array.isArray(e[0])?e[0]:e;return N(n,"createSelector expects all input-selectors to be functions, but received the following types: "),n}function x(e,n){const r=[],{length:s}=e;for(let o=0;o<s;o++)r.push(e[o].apply(null,n));return r}var I=class{constructor(e){this.value=e}deref(){return this.value}},O=typeof WeakRef<"u"?WeakRef:I,$=0,C=1;function R(){return{s:$,v:void 0,o:null,p:null}}function M(e,n={}){let r=R();const{resultEqualityCheck:s}=n;let o,c=0;function i(){var m,v;let t=r;const{length:y}=arguments;for(let p=0,h=y;p<h;p++){const f=arguments[p];if(typeof f=="function"||typeof f=="object"&&f!==null){let a=t.o;a===null&&(t.o=a=new WeakMap);const d=a.get(f);d===void 0?(t=R(),a.set(f,t)):t=d}else{let a=t.p;a===null&&(t.p=a=new Map);const d=a.get(f);d===void 0?(t=R(),a.set(f,t)):t=d}}const l=t;let u;if(t.s===C?u=t.v:(u=e.apply(null,arguments),c++),l.s=C,s){const p=(v=(m=o==null?void 0:o.deref)==null?void 0:m.call(o))!=null?v:o;p!=null&&s(p,u)&&(u=p,c!==0&&c--),o=typeof u=="object"&&u!==null||typeof u=="function"?new O(u):u}return l.v=u,u}return i.clearCache=()=>{r=R(),i.resetResultsCount()},i.resultsCount=()=>c,i.resetResultsCount=()=>{c=0},i}function W(e,...n){const r=typeof e=="function"?{memoize:e,memoizeOptions:n}:e,s=(...o)=>{let c=0,i=0,t,y={},l=o.pop();typeof l=="object"&&(y=l,l=o.pop()),T(l,"createSelector expects an output function after the inputs, but received: [".concat(typeof l,"]"));const u={...r,...y},{memoize:m,memoizeOptions:v=[],argsMemoize:p=M,argsMemoizeOptions:h=[],devModeChecks:f={}}=u,a=b(v),d=b(h),g=E(o),w=m(function(){return c++,l.apply(null,arguments)},...a),j=p(function(){i++;const S=x(g,arguments);return t=w.apply(null,S),t},...d);return Object.assign(j,{resultFunc:l,memoizedResultFunc:w,dependencies:g,dependencyRecomputations:()=>i,resetDependencyRecomputations:()=>{i=0},lastResult:()=>t,recomputations:()=>c,resetRecomputations:()=>{c=0},memoize:m,argsMemoize:p})};return Object.assign(s,{withTypes:()=>s}),s}var A=W(M),D=Object.assign((e,n=A)=>{z(e,"createStructuredSelector expects first argument to be an object where each property is a selector, instead received a ".concat(typeof e));const r=Object.keys(e),s=r.map(c=>e[c]);return n(s,(...c)=>c.reduce((i,t,y)=>(i[r[y]]=t,i),{}))},{withTypes:()=>D});export{W as c,M as w};
